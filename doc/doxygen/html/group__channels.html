<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tcm: Native Channel Implementation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tcm
   &#160;<span id="projectnumber">0.0.0-gec2b50f</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Native Channel Implementation<div class="ingroups"><a class="el" href="group__tcm.html">Asynchronous Communication Channels for TinyScheme</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__base__channel.html">t_base_channel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__client__sock__channel.html">t_client_sock_channel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__dev__channel.html">t_dev_channel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__server__sock__channel.html">t_server_sock_channel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9c094f5894249468902c2e2c318791d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#ga9c094f5894249468902c2e2c318791d9">CLIENT_SOCK_CH_MAX_DATA_SIZE</a>&#160;&#160;&#160;256</td></tr>
<tr class="separator:ga9c094f5894249468902c2e2c318791d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8caac65989c3bb2ceaf2c7627e9c9ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#gaf8caac65989c3bb2ceaf2c7627e9c9ff">CLIENT_SOCK_CH_POOL_SIZE</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:gaf8caac65989c3bb2ceaf2c7627e9c9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga209033973459f6a2c73d9389d5271afa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#ga209033973459f6a2c73d9389d5271afa">DEV_CH_MAX_DATA_SIZE</a>&#160;&#160;&#160;256</td></tr>
<tr class="separator:ga209033973459f6a2c73d9389d5271afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50b5f750582f932c433a442e6fbb3773"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#ga50b5f750582f932c433a442e6fbb3773">DEV_CH_POOL_SIZE</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:ga50b5f750582f932c433a442e6fbb3773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648e88c70328afe3c0ce5cfc53dfddb5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#ga648e88c70328afe3c0ce5cfc53dfddb5">DEV_CH_REOPEN_TIME_MS</a>&#160;&#160;&#160;1000</td></tr>
<tr class="separator:ga648e88c70328afe3c0ce5cfc53dfddb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b9b4ad8660e819a52ca14117605d6dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#ga4b9b4ad8660e819a52ca14117605d6dd">SERVER_SOCK_CH_MAX_CONNECTIONS</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:ga4b9b4ad8660e819a52ca14117605d6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77bcf605a24d9abce0c935318da57a48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#ga77bcf605a24d9abce0c935318da57a48">SERVER_SOCK_CH_MAX_DATA_SIZE</a>&#160;&#160;&#160;256</td></tr>
<tr class="separator:ga77bcf605a24d9abce0c935318da57a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecc028988b14963771006a3ad1dbde93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#gaecc028988b14963771006a3ad1dbde93">SERVER_SOCK_CH_POOL_SIZE</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:gaecc028988b14963771006a3ad1dbde93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4f382a2c3646eb5e1b83701aefb6d20c"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#ga4f382a2c3646eb5e1b83701aefb6d20c">t_channel_handler_0</a>) (struct s_base_channel *p)</td></tr>
<tr class="separator:ga4f382a2c3646eb5e1b83701aefb6d20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1182108ff364329a9199078559c16be"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#gaa1182108ff364329a9199078559c16be">t_channel_handler_1</a>) (struct s_base_channel *p, const void *p_arg)</td></tr>
<tr class="separator:gaa1182108ff364329a9199078559c16be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bb9da019696076e9fa38c178479e119"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#ga1bb9da019696076e9fa38c178479e119">t_channel_handler_2</a>) (struct s_base_channel *p, const void *p_arg, const int len)</td></tr>
<tr class="separator:ga1bb9da019696076e9fa38c178479e119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad31e35b17eece4cc6c2e87d9bda43b03"><td class="memItemLeft" align="right" valign="top">typedef t_evt_cb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#gad31e35b17eece4cc6c2e87d9bda43b03">t_channel_cb</a></td></tr>
<tr class="separator:gad31e35b17eece4cc6c2e87d9bda43b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae82d0f7b261c8c302b2ec84d2669aad3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#gae82d0f7b261c8c302b2ec84d2669aad3">t_channel_type</a> { <a class="el" href="group__channels.html#ggae82d0f7b261c8c302b2ec84d2669aad3afadb2e9537b99b8bb1e668d589b26b23">t_channel_dev_type</a>, 
<a class="el" href="group__channels.html#ggae82d0f7b261c8c302b2ec84d2669aad3a16e49034c9fe6d127bf74c45f8a055fa">t_channel_client_sock_type</a>, 
<a class="el" href="group__channels.html#ggae82d0f7b261c8c302b2ec84d2669aad3aae2722a617bebbcc1887aac24f9bb550">t_channel_server_sock_type</a>
 }</td></tr>
<tr class="separator:gae82d0f7b261c8c302b2ec84d2669aad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2adf08f2fb60bda36146babb39f2172c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structt__client__sock__channel.html">t_client_sock_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#ga2adf08f2fb60bda36146babb39f2172c">init_client_sock_channel</a> (<a class="el" href="structt__tcm__server__ctx.html">t_tcm_server_ctx</a> *p_tcm_server_ctx, const char *addr, int port, <a class="el" href="group__channels.html#gad31e35b17eece4cc6c2e87d9bda43b03">t_channel_cb</a> p_read_cb)</td></tr>
<tr class="separator:ga2adf08f2fb60bda36146babb39f2172c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8906ca09eac5f800b4b2d94ab86bdcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structt__dev__channel.html">t_dev_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#gad8906ca09eac5f800b4b2d94ab86bdcd">init_dev_channel</a> (<a class="el" href="structt__tcm__server__ctx.html">t_tcm_server_ctx</a> *p_tcm_server_ctx, const char *filename, <a class="el" href="group__channels.html#gad31e35b17eece4cc6c2e87d9bda43b03">t_channel_cb</a> p_read_cb)</td></tr>
<tr class="separator:gad8906ca09eac5f800b4b2d94ab86bdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2efc6515c53ab5f0c9800c35f65789"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#ga6b2efc6515c53ab5f0c9800c35f65789">fmemopen</a> (void *buf, size_t size, const char *mode)</td></tr>
<tr class="separator:ga6b2efc6515c53ab5f0c9800c35f65789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75058cb37fc3b24aad485f9530f4603e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structt__server__sock__channel.html">t_server_sock_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__channels.html#ga75058cb37fc3b24aad485f9530f4603e">init_server_sock_channel</a> (<a class="el" href="structt__tcm__server__ctx.html">t_tcm_server_ctx</a> *p_tcm_server_ctx, const char *addr, int port, <a class="el" href="group__channels.html#gad31e35b17eece4cc6c2e87d9bda43b03">t_channel_cb</a> p_read_cb)</td></tr>
<tr class="separator:ga75058cb37fc3b24aad485f9530f4603e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The communication channels presented here are an abstraction of processes linked to queues. This allows to sequentially process events from sereval input queues without blocking the data sources such as TCP/UDP interprocess commincation sockets and device files e.g. for serial line communication or any other I/O based data streams. The fundamental concept is strongly influenced by <a href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html">Clojure's core.async</a> library and Go language channels but the implementation given here has more in common with Javascript's event mechanism. Unlike Clojure, TinyScheme is like Javascript single threaded which is important as a precondition for its compactness and simplicity.</p>
<p>All concurrent operations for the decoupling of external data sources and synchronous processing are realized by native posix threads. The main focus of this approach is expressiveness, extensibility and compactness for applications which do not explicitly demand for maximum throughput or strict real-time capability. Many applications such as parsing, filtering and distribution of Hayes AT command sequences as presented here fall in this category. </p><pre class="fragment"> --------                        ---------                       ---------
| Socket | -- Reader Thread --&gt;  | queue |  --&gt; Proc Thread --&gt; / Scheme /
 --------                        ---------                      ---------
</pre><p>The reader thread constantly reads data from a data source which can be a file, a client or a server socket and stores the result in an data queue. The processing thread reads out elements or data chunks from that queue and feeds them into the scheme interpreter by invoking a callback function with that data. The scheme interpreter is protected by a mutex which guarantees that only one processing thread at a time can be executed. Given that the scheme programmer has not to worry about thread safeness at all. He can safely update internal state and write out data to any channel from any function respectively callback function context. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga9c094f5894249468902c2e2c318791d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CLIENT_SOCK_CH_MAX_DATA_SIZE&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum data chunk size to be read at once </p>

</div>
</div>
<a class="anchor" id="gaf8caac65989c3bb2ceaf2c7627e9c9ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CLIENT_SOCK_CH_POOL_SIZE&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of data chunks in ring buffer </p>

</div>
</div>
<a class="anchor" id="ga209033973459f6a2c73d9389d5271afa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEV_CH_MAX_DATA_SIZE&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum data chunk size to be read at once </p>

</div>
</div>
<a class="anchor" id="ga50b5f750582f932c433a442e6fbb3773"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEV_CH_POOL_SIZE&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of data chunks in ring buffer </p>

</div>
</div>
<a class="anchor" id="ga648e88c70328afe3c0ce5cfc53dfddb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEV_CH_REOPEN_TIME_MS&#160;&#160;&#160;1000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of milliseconds timeout before retry opening file </p>

</div>
</div>
<a class="anchor" id="ga4b9b4ad8660e819a52ca14117605d6dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERVER_SOCK_CH_MAX_CONNECTIONS&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum allowed connections </p>

</div>
</div>
<a class="anchor" id="ga77bcf605a24d9abce0c935318da57a48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERVER_SOCK_CH_MAX_DATA_SIZE&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum data chunk size to be read at once </p>

</div>
</div>
<a class="anchor" id="gaecc028988b14963771006a3ad1dbde93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERVER_SOCK_CH_POOL_SIZE&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of data chunks in ring buffer </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gad31e35b17eece4cc6c2e87d9bda43b03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef t_evt_cb <a class="el" href="group__channels.html#gad31e35b17eece4cc6c2e87d9bda43b03">t_channel_cb</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>event callback handler to receive data from channel</p>
<p>refer to type t_evt_cb in libintercom </p>

</div>
</div>
<a class="anchor" id="ga4f382a2c3646eb5e1b83701aefb6d20c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* t_channel_handler_0) (struct s_base_channel *p)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>request handler type 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pointer to channel instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case of success, otherwise negative error code </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1182108ff364329a9199078559c16be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* t_channel_handler_1) (struct s_base_channel *p, const void *p_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>request handler type 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pointer to channel instance </td></tr>
    <tr><td class="paramname">pointer</td><td>to first argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>intereger return code according to handler type </dd></dl>

</div>
</div>
<a class="anchor" id="ga1bb9da019696076e9fa38c178479e119"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* t_channel_handler_2) (struct s_base_channel *p, const void *p_arg, const int len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>request handler type 2</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pointer to channel instance </td></tr>
    <tr><td class="paramname">pointer</td><td>to first argument (buffer) </td></tr>
    <tr><td class="paramname">buffer</td><td>size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>intereger return code according to handler type </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gae82d0f7b261c8c302b2ec84d2669aad3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__channels.html#gae82d0f7b261c8c302b2ec84d2669aad3">t_channel_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>type of channel </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggae82d0f7b261c8c302b2ec84d2669aad3afadb2e9537b99b8bb1e668d589b26b23"></a>t_channel_dev_type&#160;</td><td class="fielddoc">
<p>file respectively device type </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae82d0f7b261c8c302b2ec84d2669aad3a16e49034c9fe6d127bf74c45f8a055fa"></a>t_channel_client_sock_type&#160;</td><td class="fielddoc">
<p>TCP or UDP client socket type </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae82d0f7b261c8c302b2ec84d2669aad3aae2722a617bebbcc1887aac24f9bb550"></a>t_channel_server_sock_type&#160;</td><td class="fielddoc">
<p>TCP or UDP server socket type </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6b2efc6515c53ab5f0c9800c35f65789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* fmemopen </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A BSD port of the fmemopen Linux method using funopen.</p>
<p>man docs for fmemopen: <a href="http://linux.die.net/man/3/fmemopen">http://linux.die.net/man/3/fmemopen</a></p>
<p>man docs for funopen: <a href="https://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man3/funopen.3.html">https://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man3/funopen.3.html</a></p>
<p>This method is ported from ingenuitas' python-tesseract project.</p>
<p>You must call fclose on the returned file pointer or memory will be leaked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The data that will be used to back the FILE* methods. Must be at least <code>size</code> bytes. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the <code>buf</code> data. </td></tr>
    <tr><td class="paramname">mode</td><td>The permitted stream operation modes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer that can be used in the fread/fwrite/fseek/fclose family of methods. If a failure occurred NULL will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2adf08f2fb60bda36146babb39f2172c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structt__client__sock__channel.html">t_client_sock_channel</a>* init_client_sock_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__tcm__server__ctx.html">t_tcm_server_ctx</a> *&#160;</td>
          <td class="paramname"><em>p_tcm_server_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__channels.html#gad31e35b17eece4cc6c2e87d9bda43b03">t_channel_cb</a>&#160;</td>
          <td class="paramname"><em>p_read_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>constructor for client socket channel</p>
<p>Creates channel queue, reader and processing thread to read and write via TCP/UDP client socket The processing thread invokes a call back function for each element in the channel queue</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_tcm_server_ctx</td><td>pointer to main instance object </td></tr>
    <tr><td class="paramname">addr</td><td>pointer to C string with ASCII representation of TCP or UDP client address to connect to </td></tr>
    <tr><td class="paramname">port</td><td>TCP port or 0 in case of UDP </td></tr>
    <tr><td class="paramname">p_read_cb</td><td>callback handler which is invoked by the processing thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to channel instance or NULL in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="gad8906ca09eac5f800b4b2d94ab86bdcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structt__dev__channel.html">t_dev_channel</a>* init_dev_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__tcm__server__ctx.html">t_tcm_server_ctx</a> *&#160;</td>
          <td class="paramname"><em>p_tcm_server_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__channels.html#gad31e35b17eece4cc6c2e87d9bda43b03">t_channel_cb</a>&#160;</td>
          <td class="paramname"><em>p_read_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>constructor for device channel</p>
<p>Creates channel queue, reader and processing thread to read and write via to a file or I/O device The processing thread invokes a call back function for each element in the channel queue</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_tcm_server_ctx</td><td>pointer to main instance object </td></tr>
    <tr><td class="paramname">filename</td><td>full qualified device or pty file name to be accessed </td></tr>
    <tr><td class="paramname">p_read_cb</td><td>callback handler which is invoked by the processing thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to channel instance or NULL in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="ga75058cb37fc3b24aad485f9530f4603e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structt__server__sock__channel.html">t_server_sock_channel</a>* init_server_sock_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__tcm__server__ctx.html">t_tcm_server_ctx</a> *&#160;</td>
          <td class="paramname"><em>p_tcm_server_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__channels.html#gad31e35b17eece4cc6c2e87d9bda43b03">t_channel_cb</a>&#160;</td>
          <td class="paramname"><em>p_read_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>constructor for server socket channel</p>
<p>Creates channel queue, reader and processing thread to read and write via TCP/UDP server socket The processing thread invokes a call back function for each element in the channel queue</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_tcm_server_ctx</td><td>pointer to main instance object </td></tr>
    <tr><td class="paramname">addr</td><td>pointer to C string with ASCII representation of TCP or UDP server address to connect to </td></tr>
    <tr><td class="paramname">port</td><td>TCP port or 0 in case of UDP </td></tr>
    <tr><td class="paramname">p_read_cb</td><td>callback handler which is invoked by the processing thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to channel instance or NULL in case of error </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 22 2016 23:13:59 for tcm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
